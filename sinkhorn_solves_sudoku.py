# -*- coding: utf-8 -*-
"""Sinkhorn Solves Sudoku.ipynb
Automatically generated by Colab.
Original file is located at
    https://colab.research.google.com/drive/16j8faNc1ifceFmc1bhgZXfBmV8OxtEcc
"""

import numpy as np
import pandas as pd
from sinkhorn_knopp import *

"""## Reading the dataset"""

# !rm -rf /root/.kaggle/
# !mkdir /root/.kaggle/
# !gdown 1RP6sqL5BJTBbn0VKXUQSx1R6PQmdgGTi
# !mv /content/kaggle.json /root/.kaggle/
# !kaggle datasets download -d bryanpark/sudoku
# !unzip /content/sudoku.zip

def print_sudoku(sudoku):

    def get_colored_elem(elem):
        return '\033[32m'+elem+'\033[0m' if elem!='0' else '\033[31m'+elem+'\033[0m'

    endseps = "\033[36m+-----------+-----------+-----------+\033[0m\n"
    midseps = "\033[36m+\033[0m-----------\033[36m+\033[0m-----------\033[36m+\033[0m-----------\033[36m+\033[0m\n"
    seps = "+-----------+-----------+-----------+\n"
    newsudoku = ''
    newsudoku = newsudoku + endseps
    for i in range(81):
        if i%9==0:
            newsudoku = newsudoku + "\033[36m" + '| ' + "\033[0m" + get_colored_elem(sudoku[i:i+1])
        elif (i+1)%9==0:
            if (i+1)%27==0:
                newsudoku = newsudoku + ' | ' + get_colored_elem(sudoku[i:i+1]) + "\033[36m" + ' |\n' + "\033[0m" + endseps
            else:
                newsudoku = newsudoku + ' | ' + get_colored_elem(sudoku[i:i+1]) + "\033[36m" + ' |\n' + "\033[0m"  + midseps
        else:
            if i%3==0 and i%9!=0:
                newsudoku = newsudoku + ' \033[36m|\033[0m ' + get_colored_elem(sudoku[i:i+1])
            else:
                newsudoku = newsudoku + ' | ' + get_colored_elem(sudoku[i:i+1])
    print(newsudoku)

"""## Modelling the contents of the cells"""
class cell:
    def __init__(self, value, index, sudoku):
        self.value = value
        self.index = index
        self.sudoku = sudoku
        self.set_pdf(sudoku)

    def set_pdf(self, sudoku):
        if self.value != '0':
            self.pdf = np.zeros((1,9))
            self.pdf[0,int(self.value)-1] = 1
        else:
            row = self.index // 9
            col = self.index % 9
            missing_values = self._check_row_(row, sudoku) + self._check_col_(col, sudoku) + self._check_sqr_(row, col, sudoku)
            missing_values = list(set(missing_values))
            # print(missing_values)
            self.pdf = np.array([1 if str(i) in missing_values else 0 for i in range(9)]).reshape((1,9)) / len(missing_values)

    def _check_row_(self, row, sudoku):
        sind = row * 9
        values = list(sudoku[sind:sind+9])
        # print(values)
        missing_values = [str(i) for i in range(9) if str(i) not in values]
        # print(missing_values)
        return missing_values

    def _check_col_(self, col, sudoku):
        # sind = row * 9
        sinds = [col+i*9 for i in range(9)]
        values = [sudoku[sind:sind+1] for sind in sinds]
        # print(values)
        missing_values = [str(i) for i in range(9) if str(i) not in values]
        # print(missing_values)
        return missing_values

    def _check_sqr_(self, row, col, sudoku):
        sqr_row = row // 3
        sqr_col = col // 3
        rows = [i for i in range(3*sqr_row, 3*sqr_row+3)]
        cols = [i for i in range(3*sqr_col, 3*sqr_col+3)]
        sinds = []
        for r in rows:
            for c in cols:
                sinds.append(r*9+c)
        values = [sudoku[sind:sind+1] for sind in sinds]
        # print(values)
        missing_values = [str(i) for i in range(9) if str(i) not in values]
        # print(missing_values)
        return missing_values

    def set_cell(self, val):
        self.value = val

    def get_cell(self):
        return self.value

    def get_pdf(self):
        return self.pdf

    def update_pdf(self, pdf):
        self.pdf = pdf


"""## Sinkhorn Balancing"""
def sinkhorn_balancer(Q, M=5, tol=1e-8):
    k = 0
    N = Q.shape[0]
    Qprev = Q
    while k < M:
        # Column balancing
        for j in range(N):
            Chij = Q[:,j].sum()
            Q[:,j] = Q[:,j] / (Chij + 1e-6)
        # Row balancing
        for i in range(N):
            rowi = Q[i,:].sum()
            Q[i,:] = Q[i,:] / (rowi + 1e-6)

        if np.sqrt(np.power(Qprev-Q, 2).sum()) < tol:
            return Q
        else:
            Qprev = Q
        k+=1
    return Q


#%%%%%%%%%%% Solution CHecker %%%%%%%%%%%%%%%%
def uniqueness_checker(sudoku):
    sudoku = np.array([[int(x) for x in list(sudoku[sind:sind+9])] for sind in range(0,81,9)])
    constraint = 0
    #%%%%%%%% Row constraints %%%%%%%%%
    for i in range(9):
        if sudoku[i,:].sum() == 45:
            constraint+=1

    #%%%%%%%% Column constraints %%%%%%%%%
    for i in range(9):
        if sudoku[:,i].sum() == 45:
            constraint+=1

    #%%%%%%%% Square constraints %%%%%%%%%
    for i in range(9):
        rows = [3*(i//3)+r for r in range(3)]
        cols = [3*(i%3)+c for c in range(3)]
        #%%%%%%%%% get pdfs and form prob constraint matrix %%%%%%%%%%%
        for r in rows:
            for c in cols:
                if sudoku[3*(i//3):3*(i//3)+3,3*(i%3):3*(i%3)+3].sum() == 45:
                    constraint+=1
        
    if constraint==27:
        return True
    else:
        return False
    

##%%%%%%%%% Sinkhorn Solution Finder %%%%%%%%%%%%%%%
def sinkhorn_solve_contraints(cells, sk):
    #%%%%%%%%%%%% Constraints grouping %%%%%%%
    #%%%%%%%% Row constraints %%%%%%%%%
    for i in range(9):
        #%%%%%%%%% get pdfs and form prob constraint matrix %%%%%%%%%%%
        Q = np.concatenate([cell.get_pdf().reshape((1,9)) for cell in cells[i,:]], axis = 0)
        #%%%%%%%%% Sinkhorn balance %%%%%%%%%%%%%%
        Q = sk.fit(Q + 1e-6) #sinkhorn_balancer(Q)
        #%%%%%%%%%% Extract probabilities %%%%%%%%%
        for r in range(9):
            cells[i,r].update_pdf(Q[r,:])

    #%%%%%%%% Column constraints %%%%%%%%%
    for i in range(9):
        #%%%%%%%%% get pdfs and form prob constraint matrix %%%%%%%%%%%
        Q = np.concatenate([cell.get_pdf().reshape((1,9)) for cell in cells[:,i]], axis = 0)
        #%%%%%%%%% Sinkhorn balance %%%%%%%%%%%%%%
        Q = sk.fit(Q + 1e-6) #sinkhorn_balancer(Q.reshape((9,9)))
        #%%%%%%%%%% Extract probabilities %%%%%%%%%
        for c in range(9):
            cells[c,i].update_pdf(Q[c,:])

    #%%%%%%%% Square constraints %%%%%%%%%
    for i in range(9):
        rows = [3*(i//3)+r for r in range(3)]
        cols = [3*(i%3)+c for c in range(3)]
        #%%%%%%%%% get pdfs and form prob constraint matrix %%%%%%%%%%%
        Q = []
        for r in rows:
            for c in cols:
                Q.append(cells[r,c].get_pdf().reshape((1,9)))
        Q = np.concatenate(Q, axis = 0)
        #%%%%%%%%% Sinkhorn balance %%%%%%%%%%%%%%
        Q = sk.fit(Q + 1e-6) #sinkhorn_balancer(Q.reshape((9,9)))
        #%%%%%%%%%% Extract probabilities %%%%%%%%%
        q = 0
        for r in rows:
            for c in cols:
                cells[r,c].update_pdf(Q[q,:])
                q+=1

    return cells


if __name__ == '__main__':
    #%%%%%%%%%%%%%% Read Sudokus %%%%%%%%%%
    sudokus = pd.read_csv('./sudoku.csv')
    probs = sudokus['quizzes']
    solts = sudokus['solutions']

    sk = SinkhornKnopp(max_iter = 1000)
    # Example Sudoku puzzle
    for num in range(1):
        sudoku = probs[num] #'040100050107003960520008000000000017000906800803050620090060543600080700250097100'
        print_sudoku(sudoku)

        #%%%%%%%%%%% Prepare Cells and PDFs %%%%%%%%%%%%
        cells = np.array([])
        for i in range(len(sudoku)):
            # print(i)
            cells = np.append(cells, cell(sudoku[i], i, sudoku))
        cells = cells.reshape((9,9))
        # for i in range(len(sudoku)):
        #     print(cells[i].get_pdf())

        ## %%%%%%%%%%% SOLVE SUDOKU %%%%%%%%%%%%%%%%%%%
        for i in range(1000):
            cells = sinkhorn_solve_contraints(cells, sk)
            for i in range(9):
                for j in range(9):
                    # if sudoku[i*9+j]=='0':
                    newval = np.argmax(cells[i,j].get_pdf().reshape(-1), axis = 0) + 1
                    cells[i,j].set_cell(str(newval))
                    sudoku = sudoku[:i*9+j]+str(newval)+sudoku[i*9+j+1:]
                    cells[i,j].set_pdf(sudoku)

        print_sudoku(sudoku)

        if uniqueness_checker(sudoku):
            print("SOLVED!!!")
        else:
            print("NOT SOLVED!!!")

        # print_sudoku(solts[num])